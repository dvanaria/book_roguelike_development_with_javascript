level, from level_1.js

    level = huge 2d array, logical (1=wall, 0=space)


board.js

    board = object
        tile_index.floor
        tile_index.wall
        initialize(scene)
            capture pointer to scene
            scene.converted_level is processed
        tilemap   (this is the main tilemap of the game)
        tilesheet (a pointer to the big image)
   
    The board file has access to level from level_1.js, in order to create
         the tilemap




player = PlayerCharacter(x,y)
    player (constructor)
         movement_points
         arrow_keys 
         x, y
         sprite_index
    refresh()
    turn()  polls arrow keys and moves sprite if space is available on board
    over()  returns true if movement_points = 0

    the PlayerCharacter class has access to the board, in order to 
    move the sprite around and do wall collision checks



turn_manager from turn_manager.js

    turn_manager = object
        interval (150 ms)
        entity_set   (a Set() of objects)
        lastCall()      returns ms
        addEntity(e)
        removeEntity(e)
        refresh()     calls the refresh() method of each Entity in the Set
        turn()        calls turn() for each entity in the Set



play_game_scene from game.js

    this file has access to board, turn_manager, and PlayerCharacter

    play_game_scene = object
        preload()   - load the spritesheet
        create()    - board.initialize(), create player, add player to turn_manager's entity set
        update()    - call the turn_manager to run turn() for each entity

    game = object (Phaser.Game())
